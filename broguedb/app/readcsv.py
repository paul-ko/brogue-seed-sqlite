import csv
from dataclasses import dataclass
from functools import cached_property
import logging
from pathlib import Path
from typing import Sequence

from broguedb.app.data import CatalogMetadata
from broguedb.app.data import CatalogObject

_logger = logging.getLogger(__name__)


class EmptyCatalogError(RuntimeError):
    pass


def read_file(path: Path) -> tuple[tuple[str, ...], ...]:
    _logger.info("Reading the CSV at %s", path.absolute())

    with path.open(encoding="UTF-8", newline="") as f:
        reader = csv.reader(f)
        next(reader)  # skip the header line generated by BrogueCE

        raw_catalog = tuple(tuple(r) for r in reader)
    if not len(raw_catalog):
        raise EmptyCatalogError()
    _logger.info("Read %d objects", len(raw_catalog))
    return raw_catalog


@dataclass(frozen=True)
class Catalog:
    raw_catalog: Sequence[Sequence[str]]

    @property
    def dungeon_version(self) -> str:
        return self.raw_catalog[0][0]

    @cached_property
    def catalog_objects(self) -> tuple[CatalogObject]:
        return tuple(CatalogObject.from_csv_row(r) for r in self.raw_catalog)

    @cached_property
    def catalog_metadata(self) -> CatalogMetadata:
        last_obj = self.raw_catalog[-1]
        return CatalogMetadata(
            dungeon_version=self.dungeon_version,
            max_depth=int(last_obj[1]),
            min_seed=int(self.raw_catalog[0][1]),
            max_seed=int(last_obj[1]),
        )

    @cached_property
    def unique_categories(self) -> frozenset[str]:
        return frozenset(r[4] for r in self.raw_catalog)

    @cached_property
    def unique_kinds(self) -> frozenset[str]:
        return frozenset(r[5] for r in self.raw_catalog)

    @cached_property
    def unique_runics(self) -> frozenset[str]:
        return frozenset(r[7] for r in self.raw_catalog if r[7] is not None)

    @cached_property
    def unique_carried_by_monster_names(self) -> frozenset[str]:
        return frozenset(r[10] for r in self.raw_catalog if r[10] is not None)

    @cached_property
    def ally_status_names(self) -> frozenset[str]:
        return frozenset(r[11] for r in self.raw_catalog if r[11] is not None)

    @cached_property
    def unique_mutation_names(self) -> frozenset[str]:
        return frozenset(r[12] for r in self.raw_catalog if r[12] is not None)


# def _build_key_value_data(
#     raw_catalog: tuple[tuple[str, ...]], field_index: int
# ) -> dict[str, int]:
#     return {
#         k: (idx + 1)
#         for idx, k in enumerate(
#             set(f[field_index] for f in raw_catalog if f[field_index] is not None)
#         )
#     }
